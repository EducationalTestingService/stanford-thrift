/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef StanfordCoreNLP_H
#define StanfordCoreNLP_H

#include <thrift/TDispatchProcessor.h>
#include "corenlp_types.h"



class StanfordCoreNLPIf {
 public:
  virtual ~StanfordCoreNLPIf() {}
  virtual void ping() = 0;
  virtual void zip() = 0;
  virtual void parse_text(std::vector<ParseTree> & _return, const std::string& text, const std::vector<std::string> & outputFormat) = 0;
  virtual void parse_tokens(ParseTree& _return, const std::vector<std::string> & tokens, const std::vector<std::string> & outputFormat) = 0;
  virtual void parse_tagged_sentence(ParseTree& _return, const std::string& taggedSentence, const std::vector<std::string> & outputFormat, const std::string& divider) = 0;
  virtual void lexicalize_parse_tree(std::string& _return, const std::string& tree) = 0;
  virtual void get_entities_from_text(std::vector<NamedEntity> & _return, const std::string& text) = 0;
  virtual void get_entities_from_tokens(std::vector<NamedEntity> & _return, const std::vector<std::string> & tokens) = 0;
  virtual void get_entities_from_trees(std::vector<NamedEntity> & _return, const std::vector<std::string> & trees) = 0;
  virtual void resolve_coreferences_in_text(std::vector<std::string> & _return, const std::string& text) = 0;
  virtual void resolve_coreferences_in_tokenized_sentences(std::vector<std::string> & _return, const std::vector<std::string> & sentencesWithTokensSeparatedBySpace) = 0;
  virtual void resolve_coreferences_in_trees(std::vector<std::string> & _return, const std::vector<std::string> & trees) = 0;
  virtual void evaluate_tregex_pattern(std::vector<std::string> & _return, const std::string& parseTree, const std::string& tregexPattern) = 0;
  virtual void tag_text(std::vector<std::vector<TaggedToken> > & _return, const std::string& untokenizedText) = 0;
  virtual void tag_tokenized_sentence(std::vector<TaggedToken> & _return, const std::vector<std::string> & tokenizedSentence) = 0;
  virtual void untokenize_sentence(std::string& _return, const std::vector<std::string> & sentenceTokens) = 0;
  virtual void tokenize_text(std::vector<std::vector<std::string> > & _return, const std::string& arbitraryText) = 0;
};

class StanfordCoreNLPIfFactory {
 public:
  typedef StanfordCoreNLPIf Handler;

  virtual ~StanfordCoreNLPIfFactory() {}

  virtual StanfordCoreNLPIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(StanfordCoreNLPIf* /* handler */) = 0;
};

class StanfordCoreNLPIfSingletonFactory : virtual public StanfordCoreNLPIfFactory {
 public:
  StanfordCoreNLPIfSingletonFactory(const boost::shared_ptr<StanfordCoreNLPIf>& iface) : iface_(iface) {}
  virtual ~StanfordCoreNLPIfSingletonFactory() {}

  virtual StanfordCoreNLPIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(StanfordCoreNLPIf* /* handler */) {}

 protected:
  boost::shared_ptr<StanfordCoreNLPIf> iface_;
};

class StanfordCoreNLPNull : virtual public StanfordCoreNLPIf {
 public:
  virtual ~StanfordCoreNLPNull() {}
  void ping() {
    return;
  }
  void zip() {
    return;
  }
  void parse_text(std::vector<ParseTree> & /* _return */, const std::string& /* text */, const std::vector<std::string> & /* outputFormat */) {
    return;
  }
  void parse_tokens(ParseTree& /* _return */, const std::vector<std::string> & /* tokens */, const std::vector<std::string> & /* outputFormat */) {
    return;
  }
  void parse_tagged_sentence(ParseTree& /* _return */, const std::string& /* taggedSentence */, const std::vector<std::string> & /* outputFormat */, const std::string& /* divider */) {
    return;
  }
  void lexicalize_parse_tree(std::string& /* _return */, const std::string& /* tree */) {
    return;
  }
  void get_entities_from_text(std::vector<NamedEntity> & /* _return */, const std::string& /* text */) {
    return;
  }
  void get_entities_from_tokens(std::vector<NamedEntity> & /* _return */, const std::vector<std::string> & /* tokens */) {
    return;
  }
  void get_entities_from_trees(std::vector<NamedEntity> & /* _return */, const std::vector<std::string> & /* trees */) {
    return;
  }
  void resolve_coreferences_in_text(std::vector<std::string> & /* _return */, const std::string& /* text */) {
    return;
  }
  void resolve_coreferences_in_tokenized_sentences(std::vector<std::string> & /* _return */, const std::vector<std::string> & /* sentencesWithTokensSeparatedBySpace */) {
    return;
  }
  void resolve_coreferences_in_trees(std::vector<std::string> & /* _return */, const std::vector<std::string> & /* trees */) {
    return;
  }
  void evaluate_tregex_pattern(std::vector<std::string> & /* _return */, const std::string& /* parseTree */, const std::string& /* tregexPattern */) {
    return;
  }
  void tag_text(std::vector<std::vector<TaggedToken> > & /* _return */, const std::string& /* untokenizedText */) {
    return;
  }
  void tag_tokenized_sentence(std::vector<TaggedToken> & /* _return */, const std::vector<std::string> & /* tokenizedSentence */) {
    return;
  }
  void untokenize_sentence(std::string& /* _return */, const std::vector<std::string> & /* sentenceTokens */) {
    return;
  }
  void tokenize_text(std::vector<std::vector<std::string> > & /* _return */, const std::string& /* arbitraryText */) {
    return;
  }
};


class StanfordCoreNLP_ping_args {
 public:

  StanfordCoreNLP_ping_args() {
  }

  virtual ~StanfordCoreNLP_ping_args() throw() {}


  bool operator == (const StanfordCoreNLP_ping_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const StanfordCoreNLP_ping_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_ping_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_ping_pargs {
 public:


  virtual ~StanfordCoreNLP_ping_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_ping_result {
 public:

  StanfordCoreNLP_ping_result() {
  }

  virtual ~StanfordCoreNLP_ping_result() throw() {}


  bool operator == (const StanfordCoreNLP_ping_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const StanfordCoreNLP_ping_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_ping_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_ping_presult {
 public:


  virtual ~StanfordCoreNLP_ping_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class StanfordCoreNLP_zip_args {
 public:

  StanfordCoreNLP_zip_args() {
  }

  virtual ~StanfordCoreNLP_zip_args() throw() {}


  bool operator == (const StanfordCoreNLP_zip_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const StanfordCoreNLP_zip_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_zip_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_zip_pargs {
 public:


  virtual ~StanfordCoreNLP_zip_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_parse_text_args__isset {
  _StanfordCoreNLP_parse_text_args__isset() : text(false), outputFormat(false) {}
  bool text;
  bool outputFormat;
} _StanfordCoreNLP_parse_text_args__isset;

class StanfordCoreNLP_parse_text_args {
 public:

  StanfordCoreNLP_parse_text_args() : text() {
  }

  virtual ~StanfordCoreNLP_parse_text_args() throw() {}

  std::string text;
  std::vector<std::string>  outputFormat;

  _StanfordCoreNLP_parse_text_args__isset __isset;

  void __set_text(const std::string& val) {
    text = val;
  }

  void __set_outputFormat(const std::vector<std::string> & val) {
    outputFormat = val;
  }

  bool operator == (const StanfordCoreNLP_parse_text_args & rhs) const
  {
    if (!(text == rhs.text))
      return false;
    if (!(outputFormat == rhs.outputFormat))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_parse_text_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_parse_text_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_parse_text_pargs {
 public:


  virtual ~StanfordCoreNLP_parse_text_pargs() throw() {}

  const std::string* text;
  const std::vector<std::string> * outputFormat;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_parse_text_result__isset {
  _StanfordCoreNLP_parse_text_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_parse_text_result__isset;

class StanfordCoreNLP_parse_text_result {
 public:

  StanfordCoreNLP_parse_text_result() {
  }

  virtual ~StanfordCoreNLP_parse_text_result() throw() {}

  std::vector<ParseTree>  success;

  _StanfordCoreNLP_parse_text_result__isset __isset;

  void __set_success(const std::vector<ParseTree> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_parse_text_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_parse_text_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_parse_text_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_parse_text_presult__isset {
  _StanfordCoreNLP_parse_text_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_parse_text_presult__isset;

class StanfordCoreNLP_parse_text_presult {
 public:


  virtual ~StanfordCoreNLP_parse_text_presult() throw() {}

  std::vector<ParseTree> * success;

  _StanfordCoreNLP_parse_text_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_parse_tokens_args__isset {
  _StanfordCoreNLP_parse_tokens_args__isset() : tokens(false), outputFormat(false) {}
  bool tokens;
  bool outputFormat;
} _StanfordCoreNLP_parse_tokens_args__isset;

class StanfordCoreNLP_parse_tokens_args {
 public:

  StanfordCoreNLP_parse_tokens_args() {
  }

  virtual ~StanfordCoreNLP_parse_tokens_args() throw() {}

  std::vector<std::string>  tokens;
  std::vector<std::string>  outputFormat;

  _StanfordCoreNLP_parse_tokens_args__isset __isset;

  void __set_tokens(const std::vector<std::string> & val) {
    tokens = val;
  }

  void __set_outputFormat(const std::vector<std::string> & val) {
    outputFormat = val;
  }

  bool operator == (const StanfordCoreNLP_parse_tokens_args & rhs) const
  {
    if (!(tokens == rhs.tokens))
      return false;
    if (!(outputFormat == rhs.outputFormat))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_parse_tokens_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_parse_tokens_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_parse_tokens_pargs {
 public:


  virtual ~StanfordCoreNLP_parse_tokens_pargs() throw() {}

  const std::vector<std::string> * tokens;
  const std::vector<std::string> * outputFormat;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_parse_tokens_result__isset {
  _StanfordCoreNLP_parse_tokens_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_parse_tokens_result__isset;

class StanfordCoreNLP_parse_tokens_result {
 public:

  StanfordCoreNLP_parse_tokens_result() {
  }

  virtual ~StanfordCoreNLP_parse_tokens_result() throw() {}

  ParseTree success;

  _StanfordCoreNLP_parse_tokens_result__isset __isset;

  void __set_success(const ParseTree& val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_parse_tokens_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_parse_tokens_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_parse_tokens_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_parse_tokens_presult__isset {
  _StanfordCoreNLP_parse_tokens_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_parse_tokens_presult__isset;

class StanfordCoreNLP_parse_tokens_presult {
 public:


  virtual ~StanfordCoreNLP_parse_tokens_presult() throw() {}

  ParseTree* success;

  _StanfordCoreNLP_parse_tokens_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_parse_tagged_sentence_args__isset {
  _StanfordCoreNLP_parse_tagged_sentence_args__isset() : taggedSentence(false), outputFormat(false), divider(false) {}
  bool taggedSentence;
  bool outputFormat;
  bool divider;
} _StanfordCoreNLP_parse_tagged_sentence_args__isset;

class StanfordCoreNLP_parse_tagged_sentence_args {
 public:

  StanfordCoreNLP_parse_tagged_sentence_args() : taggedSentence(), divider() {
  }

  virtual ~StanfordCoreNLP_parse_tagged_sentence_args() throw() {}

  std::string taggedSentence;
  std::vector<std::string>  outputFormat;
  std::string divider;

  _StanfordCoreNLP_parse_tagged_sentence_args__isset __isset;

  void __set_taggedSentence(const std::string& val) {
    taggedSentence = val;
  }

  void __set_outputFormat(const std::vector<std::string> & val) {
    outputFormat = val;
  }

  void __set_divider(const std::string& val) {
    divider = val;
  }

  bool operator == (const StanfordCoreNLP_parse_tagged_sentence_args & rhs) const
  {
    if (!(taggedSentence == rhs.taggedSentence))
      return false;
    if (!(outputFormat == rhs.outputFormat))
      return false;
    if (!(divider == rhs.divider))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_parse_tagged_sentence_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_parse_tagged_sentence_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_parse_tagged_sentence_pargs {
 public:


  virtual ~StanfordCoreNLP_parse_tagged_sentence_pargs() throw() {}

  const std::string* taggedSentence;
  const std::vector<std::string> * outputFormat;
  const std::string* divider;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_parse_tagged_sentence_result__isset {
  _StanfordCoreNLP_parse_tagged_sentence_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_parse_tagged_sentence_result__isset;

class StanfordCoreNLP_parse_tagged_sentence_result {
 public:

  StanfordCoreNLP_parse_tagged_sentence_result() {
  }

  virtual ~StanfordCoreNLP_parse_tagged_sentence_result() throw() {}

  ParseTree success;

  _StanfordCoreNLP_parse_tagged_sentence_result__isset __isset;

  void __set_success(const ParseTree& val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_parse_tagged_sentence_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_parse_tagged_sentence_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_parse_tagged_sentence_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_parse_tagged_sentence_presult__isset {
  _StanfordCoreNLP_parse_tagged_sentence_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_parse_tagged_sentence_presult__isset;

class StanfordCoreNLP_parse_tagged_sentence_presult {
 public:


  virtual ~StanfordCoreNLP_parse_tagged_sentence_presult() throw() {}

  ParseTree* success;

  _StanfordCoreNLP_parse_tagged_sentence_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_lexicalize_parse_tree_args__isset {
  _StanfordCoreNLP_lexicalize_parse_tree_args__isset() : tree(false) {}
  bool tree;
} _StanfordCoreNLP_lexicalize_parse_tree_args__isset;

class StanfordCoreNLP_lexicalize_parse_tree_args {
 public:

  StanfordCoreNLP_lexicalize_parse_tree_args() : tree() {
  }

  virtual ~StanfordCoreNLP_lexicalize_parse_tree_args() throw() {}

  std::string tree;

  _StanfordCoreNLP_lexicalize_parse_tree_args__isset __isset;

  void __set_tree(const std::string& val) {
    tree = val;
  }

  bool operator == (const StanfordCoreNLP_lexicalize_parse_tree_args & rhs) const
  {
    if (!(tree == rhs.tree))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_lexicalize_parse_tree_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_lexicalize_parse_tree_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_lexicalize_parse_tree_pargs {
 public:


  virtual ~StanfordCoreNLP_lexicalize_parse_tree_pargs() throw() {}

  const std::string* tree;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_lexicalize_parse_tree_result__isset {
  _StanfordCoreNLP_lexicalize_parse_tree_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_lexicalize_parse_tree_result__isset;

class StanfordCoreNLP_lexicalize_parse_tree_result {
 public:

  StanfordCoreNLP_lexicalize_parse_tree_result() : success() {
  }

  virtual ~StanfordCoreNLP_lexicalize_parse_tree_result() throw() {}

  std::string success;

  _StanfordCoreNLP_lexicalize_parse_tree_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_lexicalize_parse_tree_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_lexicalize_parse_tree_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_lexicalize_parse_tree_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_lexicalize_parse_tree_presult__isset {
  _StanfordCoreNLP_lexicalize_parse_tree_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_lexicalize_parse_tree_presult__isset;

class StanfordCoreNLP_lexicalize_parse_tree_presult {
 public:


  virtual ~StanfordCoreNLP_lexicalize_parse_tree_presult() throw() {}

  std::string* success;

  _StanfordCoreNLP_lexicalize_parse_tree_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_get_entities_from_text_args__isset {
  _StanfordCoreNLP_get_entities_from_text_args__isset() : text(false) {}
  bool text;
} _StanfordCoreNLP_get_entities_from_text_args__isset;

class StanfordCoreNLP_get_entities_from_text_args {
 public:

  StanfordCoreNLP_get_entities_from_text_args() : text() {
  }

  virtual ~StanfordCoreNLP_get_entities_from_text_args() throw() {}

  std::string text;

  _StanfordCoreNLP_get_entities_from_text_args__isset __isset;

  void __set_text(const std::string& val) {
    text = val;
  }

  bool operator == (const StanfordCoreNLP_get_entities_from_text_args & rhs) const
  {
    if (!(text == rhs.text))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_get_entities_from_text_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_get_entities_from_text_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_get_entities_from_text_pargs {
 public:


  virtual ~StanfordCoreNLP_get_entities_from_text_pargs() throw() {}

  const std::string* text;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_get_entities_from_text_result__isset {
  _StanfordCoreNLP_get_entities_from_text_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_get_entities_from_text_result__isset;

class StanfordCoreNLP_get_entities_from_text_result {
 public:

  StanfordCoreNLP_get_entities_from_text_result() {
  }

  virtual ~StanfordCoreNLP_get_entities_from_text_result() throw() {}

  std::vector<NamedEntity>  success;

  _StanfordCoreNLP_get_entities_from_text_result__isset __isset;

  void __set_success(const std::vector<NamedEntity> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_get_entities_from_text_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_get_entities_from_text_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_get_entities_from_text_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_get_entities_from_text_presult__isset {
  _StanfordCoreNLP_get_entities_from_text_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_get_entities_from_text_presult__isset;

class StanfordCoreNLP_get_entities_from_text_presult {
 public:


  virtual ~StanfordCoreNLP_get_entities_from_text_presult() throw() {}

  std::vector<NamedEntity> * success;

  _StanfordCoreNLP_get_entities_from_text_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_get_entities_from_tokens_args__isset {
  _StanfordCoreNLP_get_entities_from_tokens_args__isset() : tokens(false) {}
  bool tokens;
} _StanfordCoreNLP_get_entities_from_tokens_args__isset;

class StanfordCoreNLP_get_entities_from_tokens_args {
 public:

  StanfordCoreNLP_get_entities_from_tokens_args() {
  }

  virtual ~StanfordCoreNLP_get_entities_from_tokens_args() throw() {}

  std::vector<std::string>  tokens;

  _StanfordCoreNLP_get_entities_from_tokens_args__isset __isset;

  void __set_tokens(const std::vector<std::string> & val) {
    tokens = val;
  }

  bool operator == (const StanfordCoreNLP_get_entities_from_tokens_args & rhs) const
  {
    if (!(tokens == rhs.tokens))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_get_entities_from_tokens_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_get_entities_from_tokens_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_get_entities_from_tokens_pargs {
 public:


  virtual ~StanfordCoreNLP_get_entities_from_tokens_pargs() throw() {}

  const std::vector<std::string> * tokens;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_get_entities_from_tokens_result__isset {
  _StanfordCoreNLP_get_entities_from_tokens_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_get_entities_from_tokens_result__isset;

class StanfordCoreNLP_get_entities_from_tokens_result {
 public:

  StanfordCoreNLP_get_entities_from_tokens_result() {
  }

  virtual ~StanfordCoreNLP_get_entities_from_tokens_result() throw() {}

  std::vector<NamedEntity>  success;

  _StanfordCoreNLP_get_entities_from_tokens_result__isset __isset;

  void __set_success(const std::vector<NamedEntity> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_get_entities_from_tokens_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_get_entities_from_tokens_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_get_entities_from_tokens_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_get_entities_from_tokens_presult__isset {
  _StanfordCoreNLP_get_entities_from_tokens_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_get_entities_from_tokens_presult__isset;

class StanfordCoreNLP_get_entities_from_tokens_presult {
 public:


  virtual ~StanfordCoreNLP_get_entities_from_tokens_presult() throw() {}

  std::vector<NamedEntity> * success;

  _StanfordCoreNLP_get_entities_from_tokens_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_get_entities_from_trees_args__isset {
  _StanfordCoreNLP_get_entities_from_trees_args__isset() : trees(false) {}
  bool trees;
} _StanfordCoreNLP_get_entities_from_trees_args__isset;

class StanfordCoreNLP_get_entities_from_trees_args {
 public:

  StanfordCoreNLP_get_entities_from_trees_args() {
  }

  virtual ~StanfordCoreNLP_get_entities_from_trees_args() throw() {}

  std::vector<std::string>  trees;

  _StanfordCoreNLP_get_entities_from_trees_args__isset __isset;

  void __set_trees(const std::vector<std::string> & val) {
    trees = val;
  }

  bool operator == (const StanfordCoreNLP_get_entities_from_trees_args & rhs) const
  {
    if (!(trees == rhs.trees))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_get_entities_from_trees_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_get_entities_from_trees_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_get_entities_from_trees_pargs {
 public:


  virtual ~StanfordCoreNLP_get_entities_from_trees_pargs() throw() {}

  const std::vector<std::string> * trees;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_get_entities_from_trees_result__isset {
  _StanfordCoreNLP_get_entities_from_trees_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_get_entities_from_trees_result__isset;

class StanfordCoreNLP_get_entities_from_trees_result {
 public:

  StanfordCoreNLP_get_entities_from_trees_result() {
  }

  virtual ~StanfordCoreNLP_get_entities_from_trees_result() throw() {}

  std::vector<NamedEntity>  success;

  _StanfordCoreNLP_get_entities_from_trees_result__isset __isset;

  void __set_success(const std::vector<NamedEntity> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_get_entities_from_trees_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_get_entities_from_trees_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_get_entities_from_trees_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_get_entities_from_trees_presult__isset {
  _StanfordCoreNLP_get_entities_from_trees_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_get_entities_from_trees_presult__isset;

class StanfordCoreNLP_get_entities_from_trees_presult {
 public:


  virtual ~StanfordCoreNLP_get_entities_from_trees_presult() throw() {}

  std::vector<NamedEntity> * success;

  _StanfordCoreNLP_get_entities_from_trees_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_text_args__isset {
  _StanfordCoreNLP_resolve_coreferences_in_text_args__isset() : text(false) {}
  bool text;
} _StanfordCoreNLP_resolve_coreferences_in_text_args__isset;

class StanfordCoreNLP_resolve_coreferences_in_text_args {
 public:

  StanfordCoreNLP_resolve_coreferences_in_text_args() : text() {
  }

  virtual ~StanfordCoreNLP_resolve_coreferences_in_text_args() throw() {}

  std::string text;

  _StanfordCoreNLP_resolve_coreferences_in_text_args__isset __isset;

  void __set_text(const std::string& val) {
    text = val;
  }

  bool operator == (const StanfordCoreNLP_resolve_coreferences_in_text_args & rhs) const
  {
    if (!(text == rhs.text))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_resolve_coreferences_in_text_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_resolve_coreferences_in_text_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_resolve_coreferences_in_text_pargs {
 public:


  virtual ~StanfordCoreNLP_resolve_coreferences_in_text_pargs() throw() {}

  const std::string* text;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_text_result__isset {
  _StanfordCoreNLP_resolve_coreferences_in_text_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_resolve_coreferences_in_text_result__isset;

class StanfordCoreNLP_resolve_coreferences_in_text_result {
 public:

  StanfordCoreNLP_resolve_coreferences_in_text_result() {
  }

  virtual ~StanfordCoreNLP_resolve_coreferences_in_text_result() throw() {}

  std::vector<std::string>  success;

  _StanfordCoreNLP_resolve_coreferences_in_text_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_resolve_coreferences_in_text_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_resolve_coreferences_in_text_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_resolve_coreferences_in_text_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_text_presult__isset {
  _StanfordCoreNLP_resolve_coreferences_in_text_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_resolve_coreferences_in_text_presult__isset;

class StanfordCoreNLP_resolve_coreferences_in_text_presult {
 public:


  virtual ~StanfordCoreNLP_resolve_coreferences_in_text_presult() throw() {}

  std::vector<std::string> * success;

  _StanfordCoreNLP_resolve_coreferences_in_text_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args__isset {
  _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args__isset() : sentencesWithTokensSeparatedBySpace(false) {}
  bool sentencesWithTokensSeparatedBySpace;
} _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args__isset;

class StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args {
 public:

  StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args() {
  }

  virtual ~StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args() throw() {}

  std::vector<std::string>  sentencesWithTokensSeparatedBySpace;

  _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args__isset __isset;

  void __set_sentencesWithTokensSeparatedBySpace(const std::vector<std::string> & val) {
    sentencesWithTokensSeparatedBySpace = val;
  }

  bool operator == (const StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args & rhs) const
  {
    if (!(sentencesWithTokensSeparatedBySpace == rhs.sentencesWithTokensSeparatedBySpace))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_pargs {
 public:


  virtual ~StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_pargs() throw() {}

  const std::vector<std::string> * sentencesWithTokensSeparatedBySpace;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result__isset {
  _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result__isset;

class StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result {
 public:

  StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result() {
  }

  virtual ~StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result() throw() {}

  std::vector<std::string>  success;

  _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_presult__isset {
  _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_presult__isset;

class StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_presult {
 public:


  virtual ~StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_presult() throw() {}

  std::vector<std::string> * success;

  _StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_trees_args__isset {
  _StanfordCoreNLP_resolve_coreferences_in_trees_args__isset() : trees(false) {}
  bool trees;
} _StanfordCoreNLP_resolve_coreferences_in_trees_args__isset;

class StanfordCoreNLP_resolve_coreferences_in_trees_args {
 public:

  StanfordCoreNLP_resolve_coreferences_in_trees_args() {
  }

  virtual ~StanfordCoreNLP_resolve_coreferences_in_trees_args() throw() {}

  std::vector<std::string>  trees;

  _StanfordCoreNLP_resolve_coreferences_in_trees_args__isset __isset;

  void __set_trees(const std::vector<std::string> & val) {
    trees = val;
  }

  bool operator == (const StanfordCoreNLP_resolve_coreferences_in_trees_args & rhs) const
  {
    if (!(trees == rhs.trees))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_resolve_coreferences_in_trees_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_resolve_coreferences_in_trees_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_resolve_coreferences_in_trees_pargs {
 public:


  virtual ~StanfordCoreNLP_resolve_coreferences_in_trees_pargs() throw() {}

  const std::vector<std::string> * trees;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_trees_result__isset {
  _StanfordCoreNLP_resolve_coreferences_in_trees_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_resolve_coreferences_in_trees_result__isset;

class StanfordCoreNLP_resolve_coreferences_in_trees_result {
 public:

  StanfordCoreNLP_resolve_coreferences_in_trees_result() {
  }

  virtual ~StanfordCoreNLP_resolve_coreferences_in_trees_result() throw() {}

  std::vector<std::string>  success;

  _StanfordCoreNLP_resolve_coreferences_in_trees_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_resolve_coreferences_in_trees_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_resolve_coreferences_in_trees_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_resolve_coreferences_in_trees_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_resolve_coreferences_in_trees_presult__isset {
  _StanfordCoreNLP_resolve_coreferences_in_trees_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_resolve_coreferences_in_trees_presult__isset;

class StanfordCoreNLP_resolve_coreferences_in_trees_presult {
 public:


  virtual ~StanfordCoreNLP_resolve_coreferences_in_trees_presult() throw() {}

  std::vector<std::string> * success;

  _StanfordCoreNLP_resolve_coreferences_in_trees_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_evaluate_tregex_pattern_args__isset {
  _StanfordCoreNLP_evaluate_tregex_pattern_args__isset() : parseTree(false), tregexPattern(false) {}
  bool parseTree;
  bool tregexPattern;
} _StanfordCoreNLP_evaluate_tregex_pattern_args__isset;

class StanfordCoreNLP_evaluate_tregex_pattern_args {
 public:

  StanfordCoreNLP_evaluate_tregex_pattern_args() : parseTree(), tregexPattern() {
  }

  virtual ~StanfordCoreNLP_evaluate_tregex_pattern_args() throw() {}

  std::string parseTree;
  std::string tregexPattern;

  _StanfordCoreNLP_evaluate_tregex_pattern_args__isset __isset;

  void __set_parseTree(const std::string& val) {
    parseTree = val;
  }

  void __set_tregexPattern(const std::string& val) {
    tregexPattern = val;
  }

  bool operator == (const StanfordCoreNLP_evaluate_tregex_pattern_args & rhs) const
  {
    if (!(parseTree == rhs.parseTree))
      return false;
    if (!(tregexPattern == rhs.tregexPattern))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_evaluate_tregex_pattern_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_evaluate_tregex_pattern_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_evaluate_tregex_pattern_pargs {
 public:


  virtual ~StanfordCoreNLP_evaluate_tregex_pattern_pargs() throw() {}

  const std::string* parseTree;
  const std::string* tregexPattern;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_evaluate_tregex_pattern_result__isset {
  _StanfordCoreNLP_evaluate_tregex_pattern_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_evaluate_tregex_pattern_result__isset;

class StanfordCoreNLP_evaluate_tregex_pattern_result {
 public:

  StanfordCoreNLP_evaluate_tregex_pattern_result() {
  }

  virtual ~StanfordCoreNLP_evaluate_tregex_pattern_result() throw() {}

  std::vector<std::string>  success;

  _StanfordCoreNLP_evaluate_tregex_pattern_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_evaluate_tregex_pattern_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_evaluate_tregex_pattern_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_evaluate_tregex_pattern_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_evaluate_tregex_pattern_presult__isset {
  _StanfordCoreNLP_evaluate_tregex_pattern_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_evaluate_tregex_pattern_presult__isset;

class StanfordCoreNLP_evaluate_tregex_pattern_presult {
 public:


  virtual ~StanfordCoreNLP_evaluate_tregex_pattern_presult() throw() {}

  std::vector<std::string> * success;

  _StanfordCoreNLP_evaluate_tregex_pattern_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_tag_text_args__isset {
  _StanfordCoreNLP_tag_text_args__isset() : untokenizedText(false) {}
  bool untokenizedText;
} _StanfordCoreNLP_tag_text_args__isset;

class StanfordCoreNLP_tag_text_args {
 public:

  StanfordCoreNLP_tag_text_args() : untokenizedText() {
  }

  virtual ~StanfordCoreNLP_tag_text_args() throw() {}

  std::string untokenizedText;

  _StanfordCoreNLP_tag_text_args__isset __isset;

  void __set_untokenizedText(const std::string& val) {
    untokenizedText = val;
  }

  bool operator == (const StanfordCoreNLP_tag_text_args & rhs) const
  {
    if (!(untokenizedText == rhs.untokenizedText))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_tag_text_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_tag_text_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_tag_text_pargs {
 public:


  virtual ~StanfordCoreNLP_tag_text_pargs() throw() {}

  const std::string* untokenizedText;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_tag_text_result__isset {
  _StanfordCoreNLP_tag_text_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_tag_text_result__isset;

class StanfordCoreNLP_tag_text_result {
 public:

  StanfordCoreNLP_tag_text_result() {
  }

  virtual ~StanfordCoreNLP_tag_text_result() throw() {}

  std::vector<std::vector<TaggedToken> >  success;

  _StanfordCoreNLP_tag_text_result__isset __isset;

  void __set_success(const std::vector<std::vector<TaggedToken> > & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_tag_text_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_tag_text_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_tag_text_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_tag_text_presult__isset {
  _StanfordCoreNLP_tag_text_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_tag_text_presult__isset;

class StanfordCoreNLP_tag_text_presult {
 public:


  virtual ~StanfordCoreNLP_tag_text_presult() throw() {}

  std::vector<std::vector<TaggedToken> > * success;

  _StanfordCoreNLP_tag_text_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_tag_tokenized_sentence_args__isset {
  _StanfordCoreNLP_tag_tokenized_sentence_args__isset() : tokenizedSentence(false) {}
  bool tokenizedSentence;
} _StanfordCoreNLP_tag_tokenized_sentence_args__isset;

class StanfordCoreNLP_tag_tokenized_sentence_args {
 public:

  StanfordCoreNLP_tag_tokenized_sentence_args() {
  }

  virtual ~StanfordCoreNLP_tag_tokenized_sentence_args() throw() {}

  std::vector<std::string>  tokenizedSentence;

  _StanfordCoreNLP_tag_tokenized_sentence_args__isset __isset;

  void __set_tokenizedSentence(const std::vector<std::string> & val) {
    tokenizedSentence = val;
  }

  bool operator == (const StanfordCoreNLP_tag_tokenized_sentence_args & rhs) const
  {
    if (!(tokenizedSentence == rhs.tokenizedSentence))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_tag_tokenized_sentence_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_tag_tokenized_sentence_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_tag_tokenized_sentence_pargs {
 public:


  virtual ~StanfordCoreNLP_tag_tokenized_sentence_pargs() throw() {}

  const std::vector<std::string> * tokenizedSentence;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_tag_tokenized_sentence_result__isset {
  _StanfordCoreNLP_tag_tokenized_sentence_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_tag_tokenized_sentence_result__isset;

class StanfordCoreNLP_tag_tokenized_sentence_result {
 public:

  StanfordCoreNLP_tag_tokenized_sentence_result() {
  }

  virtual ~StanfordCoreNLP_tag_tokenized_sentence_result() throw() {}

  std::vector<TaggedToken>  success;

  _StanfordCoreNLP_tag_tokenized_sentence_result__isset __isset;

  void __set_success(const std::vector<TaggedToken> & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_tag_tokenized_sentence_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_tag_tokenized_sentence_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_tag_tokenized_sentence_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_tag_tokenized_sentence_presult__isset {
  _StanfordCoreNLP_tag_tokenized_sentence_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_tag_tokenized_sentence_presult__isset;

class StanfordCoreNLP_tag_tokenized_sentence_presult {
 public:


  virtual ~StanfordCoreNLP_tag_tokenized_sentence_presult() throw() {}

  std::vector<TaggedToken> * success;

  _StanfordCoreNLP_tag_tokenized_sentence_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_untokenize_sentence_args__isset {
  _StanfordCoreNLP_untokenize_sentence_args__isset() : sentenceTokens(false) {}
  bool sentenceTokens;
} _StanfordCoreNLP_untokenize_sentence_args__isset;

class StanfordCoreNLP_untokenize_sentence_args {
 public:

  StanfordCoreNLP_untokenize_sentence_args() {
  }

  virtual ~StanfordCoreNLP_untokenize_sentence_args() throw() {}

  std::vector<std::string>  sentenceTokens;

  _StanfordCoreNLP_untokenize_sentence_args__isset __isset;

  void __set_sentenceTokens(const std::vector<std::string> & val) {
    sentenceTokens = val;
  }

  bool operator == (const StanfordCoreNLP_untokenize_sentence_args & rhs) const
  {
    if (!(sentenceTokens == rhs.sentenceTokens))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_untokenize_sentence_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_untokenize_sentence_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_untokenize_sentence_pargs {
 public:


  virtual ~StanfordCoreNLP_untokenize_sentence_pargs() throw() {}

  const std::vector<std::string> * sentenceTokens;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_untokenize_sentence_result__isset {
  _StanfordCoreNLP_untokenize_sentence_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_untokenize_sentence_result__isset;

class StanfordCoreNLP_untokenize_sentence_result {
 public:

  StanfordCoreNLP_untokenize_sentence_result() : success() {
  }

  virtual ~StanfordCoreNLP_untokenize_sentence_result() throw() {}

  std::string success;

  _StanfordCoreNLP_untokenize_sentence_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_untokenize_sentence_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_untokenize_sentence_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_untokenize_sentence_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_untokenize_sentence_presult__isset {
  _StanfordCoreNLP_untokenize_sentence_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_untokenize_sentence_presult__isset;

class StanfordCoreNLP_untokenize_sentence_presult {
 public:


  virtual ~StanfordCoreNLP_untokenize_sentence_presult() throw() {}

  std::string* success;

  _StanfordCoreNLP_untokenize_sentence_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _StanfordCoreNLP_tokenize_text_args__isset {
  _StanfordCoreNLP_tokenize_text_args__isset() : arbitraryText(false) {}
  bool arbitraryText;
} _StanfordCoreNLP_tokenize_text_args__isset;

class StanfordCoreNLP_tokenize_text_args {
 public:

  StanfordCoreNLP_tokenize_text_args() : arbitraryText() {
  }

  virtual ~StanfordCoreNLP_tokenize_text_args() throw() {}

  std::string arbitraryText;

  _StanfordCoreNLP_tokenize_text_args__isset __isset;

  void __set_arbitraryText(const std::string& val) {
    arbitraryText = val;
  }

  bool operator == (const StanfordCoreNLP_tokenize_text_args & rhs) const
  {
    if (!(arbitraryText == rhs.arbitraryText))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_tokenize_text_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_tokenize_text_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class StanfordCoreNLP_tokenize_text_pargs {
 public:


  virtual ~StanfordCoreNLP_tokenize_text_pargs() throw() {}

  const std::string* arbitraryText;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_tokenize_text_result__isset {
  _StanfordCoreNLP_tokenize_text_result__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_tokenize_text_result__isset;

class StanfordCoreNLP_tokenize_text_result {
 public:

  StanfordCoreNLP_tokenize_text_result() {
  }

  virtual ~StanfordCoreNLP_tokenize_text_result() throw() {}

  std::vector<std::vector<std::string> >  success;

  _StanfordCoreNLP_tokenize_text_result__isset __isset;

  void __set_success(const std::vector<std::vector<std::string> > & val) {
    success = val;
  }

  bool operator == (const StanfordCoreNLP_tokenize_text_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const StanfordCoreNLP_tokenize_text_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StanfordCoreNLP_tokenize_text_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _StanfordCoreNLP_tokenize_text_presult__isset {
  _StanfordCoreNLP_tokenize_text_presult__isset() : success(false) {}
  bool success;
} _StanfordCoreNLP_tokenize_text_presult__isset;

class StanfordCoreNLP_tokenize_text_presult {
 public:


  virtual ~StanfordCoreNLP_tokenize_text_presult() throw() {}

  std::vector<std::vector<std::string> > * success;

  _StanfordCoreNLP_tokenize_text_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class StanfordCoreNLPClient : virtual public StanfordCoreNLPIf {
 public:
  StanfordCoreNLPClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  StanfordCoreNLPClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void ping();
  void send_ping();
  void recv_ping();
  void zip();
  void send_zip();
  void parse_text(std::vector<ParseTree> & _return, const std::string& text, const std::vector<std::string> & outputFormat);
  void send_parse_text(const std::string& text, const std::vector<std::string> & outputFormat);
  void recv_parse_text(std::vector<ParseTree> & _return);
  void parse_tokens(ParseTree& _return, const std::vector<std::string> & tokens, const std::vector<std::string> & outputFormat);
  void send_parse_tokens(const std::vector<std::string> & tokens, const std::vector<std::string> & outputFormat);
  void recv_parse_tokens(ParseTree& _return);
  void parse_tagged_sentence(ParseTree& _return, const std::string& taggedSentence, const std::vector<std::string> & outputFormat, const std::string& divider);
  void send_parse_tagged_sentence(const std::string& taggedSentence, const std::vector<std::string> & outputFormat, const std::string& divider);
  void recv_parse_tagged_sentence(ParseTree& _return);
  void lexicalize_parse_tree(std::string& _return, const std::string& tree);
  void send_lexicalize_parse_tree(const std::string& tree);
  void recv_lexicalize_parse_tree(std::string& _return);
  void get_entities_from_text(std::vector<NamedEntity> & _return, const std::string& text);
  void send_get_entities_from_text(const std::string& text);
  void recv_get_entities_from_text(std::vector<NamedEntity> & _return);
  void get_entities_from_tokens(std::vector<NamedEntity> & _return, const std::vector<std::string> & tokens);
  void send_get_entities_from_tokens(const std::vector<std::string> & tokens);
  void recv_get_entities_from_tokens(std::vector<NamedEntity> & _return);
  void get_entities_from_trees(std::vector<NamedEntity> & _return, const std::vector<std::string> & trees);
  void send_get_entities_from_trees(const std::vector<std::string> & trees);
  void recv_get_entities_from_trees(std::vector<NamedEntity> & _return);
  void resolve_coreferences_in_text(std::vector<std::string> & _return, const std::string& text);
  void send_resolve_coreferences_in_text(const std::string& text);
  void recv_resolve_coreferences_in_text(std::vector<std::string> & _return);
  void resolve_coreferences_in_tokenized_sentences(std::vector<std::string> & _return, const std::vector<std::string> & sentencesWithTokensSeparatedBySpace);
  void send_resolve_coreferences_in_tokenized_sentences(const std::vector<std::string> & sentencesWithTokensSeparatedBySpace);
  void recv_resolve_coreferences_in_tokenized_sentences(std::vector<std::string> & _return);
  void resolve_coreferences_in_trees(std::vector<std::string> & _return, const std::vector<std::string> & trees);
  void send_resolve_coreferences_in_trees(const std::vector<std::string> & trees);
  void recv_resolve_coreferences_in_trees(std::vector<std::string> & _return);
  void evaluate_tregex_pattern(std::vector<std::string> & _return, const std::string& parseTree, const std::string& tregexPattern);
  void send_evaluate_tregex_pattern(const std::string& parseTree, const std::string& tregexPattern);
  void recv_evaluate_tregex_pattern(std::vector<std::string> & _return);
  void tag_text(std::vector<std::vector<TaggedToken> > & _return, const std::string& untokenizedText);
  void send_tag_text(const std::string& untokenizedText);
  void recv_tag_text(std::vector<std::vector<TaggedToken> > & _return);
  void tag_tokenized_sentence(std::vector<TaggedToken> & _return, const std::vector<std::string> & tokenizedSentence);
  void send_tag_tokenized_sentence(const std::vector<std::string> & tokenizedSentence);
  void recv_tag_tokenized_sentence(std::vector<TaggedToken> & _return);
  void untokenize_sentence(std::string& _return, const std::vector<std::string> & sentenceTokens);
  void send_untokenize_sentence(const std::vector<std::string> & sentenceTokens);
  void recv_untokenize_sentence(std::string& _return);
  void tokenize_text(std::vector<std::vector<std::string> > & _return, const std::string& arbitraryText);
  void send_tokenize_text(const std::string& arbitraryText);
  void recv_tokenize_text(std::vector<std::vector<std::string> > & _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class StanfordCoreNLPProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<StanfordCoreNLPIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (StanfordCoreNLPProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_ping(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_zip(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_parse_text(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_parse_tokens(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_parse_tagged_sentence(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_lexicalize_parse_tree(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_entities_from_text(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_entities_from_tokens(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_entities_from_trees(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resolve_coreferences_in_text(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resolve_coreferences_in_tokenized_sentences(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resolve_coreferences_in_trees(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_evaluate_tregex_pattern(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_tag_text(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_tag_tokenized_sentence(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_untokenize_sentence(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_tokenize_text(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  StanfordCoreNLPProcessor(boost::shared_ptr<StanfordCoreNLPIf> iface) :
    iface_(iface) {
    processMap_["ping"] = &StanfordCoreNLPProcessor::process_ping;
    processMap_["zip"] = &StanfordCoreNLPProcessor::process_zip;
    processMap_["parse_text"] = &StanfordCoreNLPProcessor::process_parse_text;
    processMap_["parse_tokens"] = &StanfordCoreNLPProcessor::process_parse_tokens;
    processMap_["parse_tagged_sentence"] = &StanfordCoreNLPProcessor::process_parse_tagged_sentence;
    processMap_["lexicalize_parse_tree"] = &StanfordCoreNLPProcessor::process_lexicalize_parse_tree;
    processMap_["get_entities_from_text"] = &StanfordCoreNLPProcessor::process_get_entities_from_text;
    processMap_["get_entities_from_tokens"] = &StanfordCoreNLPProcessor::process_get_entities_from_tokens;
    processMap_["get_entities_from_trees"] = &StanfordCoreNLPProcessor::process_get_entities_from_trees;
    processMap_["resolve_coreferences_in_text"] = &StanfordCoreNLPProcessor::process_resolve_coreferences_in_text;
    processMap_["resolve_coreferences_in_tokenized_sentences"] = &StanfordCoreNLPProcessor::process_resolve_coreferences_in_tokenized_sentences;
    processMap_["resolve_coreferences_in_trees"] = &StanfordCoreNLPProcessor::process_resolve_coreferences_in_trees;
    processMap_["evaluate_tregex_pattern"] = &StanfordCoreNLPProcessor::process_evaluate_tregex_pattern;
    processMap_["tag_text"] = &StanfordCoreNLPProcessor::process_tag_text;
    processMap_["tag_tokenized_sentence"] = &StanfordCoreNLPProcessor::process_tag_tokenized_sentence;
    processMap_["untokenize_sentence"] = &StanfordCoreNLPProcessor::process_untokenize_sentence;
    processMap_["tokenize_text"] = &StanfordCoreNLPProcessor::process_tokenize_text;
  }

  virtual ~StanfordCoreNLPProcessor() {}
};

class StanfordCoreNLPProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  StanfordCoreNLPProcessorFactory(const ::boost::shared_ptr< StanfordCoreNLPIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< StanfordCoreNLPIfFactory > handlerFactory_;
};

class StanfordCoreNLPMultiface : virtual public StanfordCoreNLPIf {
 public:
  StanfordCoreNLPMultiface(std::vector<boost::shared_ptr<StanfordCoreNLPIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~StanfordCoreNLPMultiface() {}
 protected:
  std::vector<boost::shared_ptr<StanfordCoreNLPIf> > ifaces_;
  StanfordCoreNLPMultiface() {}
  void add(boost::shared_ptr<StanfordCoreNLPIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void ping() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ping();
    }
    ifaces_[i]->ping();
  }

  void zip() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->zip();
    }
    ifaces_[i]->zip();
  }

  void parse_text(std::vector<ParseTree> & _return, const std::string& text, const std::vector<std::string> & outputFormat) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->parse_text(_return, text, outputFormat);
    }
    ifaces_[i]->parse_text(_return, text, outputFormat);
    return;
  }

  void parse_tokens(ParseTree& _return, const std::vector<std::string> & tokens, const std::vector<std::string> & outputFormat) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->parse_tokens(_return, tokens, outputFormat);
    }
    ifaces_[i]->parse_tokens(_return, tokens, outputFormat);
    return;
  }

  void parse_tagged_sentence(ParseTree& _return, const std::string& taggedSentence, const std::vector<std::string> & outputFormat, const std::string& divider) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->parse_tagged_sentence(_return, taggedSentence, outputFormat, divider);
    }
    ifaces_[i]->parse_tagged_sentence(_return, taggedSentence, outputFormat, divider);
    return;
  }

  void lexicalize_parse_tree(std::string& _return, const std::string& tree) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->lexicalize_parse_tree(_return, tree);
    }
    ifaces_[i]->lexicalize_parse_tree(_return, tree);
    return;
  }

  void get_entities_from_text(std::vector<NamedEntity> & _return, const std::string& text) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_entities_from_text(_return, text);
    }
    ifaces_[i]->get_entities_from_text(_return, text);
    return;
  }

  void get_entities_from_tokens(std::vector<NamedEntity> & _return, const std::vector<std::string> & tokens) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_entities_from_tokens(_return, tokens);
    }
    ifaces_[i]->get_entities_from_tokens(_return, tokens);
    return;
  }

  void get_entities_from_trees(std::vector<NamedEntity> & _return, const std::vector<std::string> & trees) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_entities_from_trees(_return, trees);
    }
    ifaces_[i]->get_entities_from_trees(_return, trees);
    return;
  }

  void resolve_coreferences_in_text(std::vector<std::string> & _return, const std::string& text) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resolve_coreferences_in_text(_return, text);
    }
    ifaces_[i]->resolve_coreferences_in_text(_return, text);
    return;
  }

  void resolve_coreferences_in_tokenized_sentences(std::vector<std::string> & _return, const std::vector<std::string> & sentencesWithTokensSeparatedBySpace) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resolve_coreferences_in_tokenized_sentences(_return, sentencesWithTokensSeparatedBySpace);
    }
    ifaces_[i]->resolve_coreferences_in_tokenized_sentences(_return, sentencesWithTokensSeparatedBySpace);
    return;
  }

  void resolve_coreferences_in_trees(std::vector<std::string> & _return, const std::vector<std::string> & trees) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resolve_coreferences_in_trees(_return, trees);
    }
    ifaces_[i]->resolve_coreferences_in_trees(_return, trees);
    return;
  }

  void evaluate_tregex_pattern(std::vector<std::string> & _return, const std::string& parseTree, const std::string& tregexPattern) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->evaluate_tregex_pattern(_return, parseTree, tregexPattern);
    }
    ifaces_[i]->evaluate_tregex_pattern(_return, parseTree, tregexPattern);
    return;
  }

  void tag_text(std::vector<std::vector<TaggedToken> > & _return, const std::string& untokenizedText) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->tag_text(_return, untokenizedText);
    }
    ifaces_[i]->tag_text(_return, untokenizedText);
    return;
  }

  void tag_tokenized_sentence(std::vector<TaggedToken> & _return, const std::vector<std::string> & tokenizedSentence) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->tag_tokenized_sentence(_return, tokenizedSentence);
    }
    ifaces_[i]->tag_tokenized_sentence(_return, tokenizedSentence);
    return;
  }

  void untokenize_sentence(std::string& _return, const std::vector<std::string> & sentenceTokens) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->untokenize_sentence(_return, sentenceTokens);
    }
    ifaces_[i]->untokenize_sentence(_return, sentenceTokens);
    return;
  }

  void tokenize_text(std::vector<std::vector<std::string> > & _return, const std::string& arbitraryText) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->tokenize_text(_return, arbitraryText);
    }
    ifaces_[i]->tokenize_text(_return, arbitraryText);
    return;
  }

};



#endif
